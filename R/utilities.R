# Set a default value if an object is null
#
# @param lhs An object to set if it's null
# @param rhs The value to provide if x is null
#
# @return rhs if lhs is null, else lhs
#
# @author Hadley Wickham
# @references https://adv-r.hadley.nz/functions.html#missing-arguments
#
`%||%` <- function(lhs, rhs) {
  if (!is.null(x = lhs)) {
    return(lhs)
  } else {
    return(rhs)
  }
}

#' StringToGRanges
#'
#' Convert a genomic coordinate string to a GRanges object
#'
#' @param regions Vector of genomic region strings
#' @return Returns a GRanges object
#' @importFrom GenomicRanges GRanges
#' @importFrom IRanges IRanges
#' @examples
#' regions <- c('chr1:1-10', 'chr2:12-3121')
#' StringToGRanges(regions = regions)
#'
#' @export
StringToGRanges <- function(regions) {
  chrom <- sapply(X = regions, FUN = function(a) {unlist(x = strsplit(x = a, split = ':'))[[1]]})
  coords <- sapply(X = regions, FUN = function(a) {unlist(x = strsplit(x = a, split = ':'))[[2]]})
  start <- sapply(X = coords, function(a) {as.numeric(x = unlist(x = strsplit(x = a, split = '-')))[[1]]})
  end <- sapply(X = coords, function(a) {as.numeric(x = unlist(x = strsplit(x = a, split = '-')))[[2]]})
  gr <- GRanges(seqnames = chrom, ranges = IRanges(start = start, end = end))
  return(gr)
}

#' CalculateCoverages
#'
#' Calculate normalized read coverage per base per cell group
#'
#' @param reads Dataframe containing reads for a region, generated by \code{GetReadsInRegion}
#' @param window Smoothing window to use
#'
#' @importFrom zoo rollapply
#' @importFrom dplyr bind_rows
#' @export
CalculateCoverages <- function(
  reads,
  window = 100
) {
  cells.per.group <- table(reads$group)
  lut <- as.vector(x = cells.per.group)
  names(lut) <- names(x = cells.per.group)
  expanded <- bind_rows(lapply(X = 1:nrow(reads), FUN = function(x) {
    interval = reads[x, 'start']:reads[x, 'stop']
    return(data.frame(position = interval, value = 1, cell = reads[x, 'cell'], group = reads[x, 'group']))
  }))
  expanded$norm.value <- expanded$value / as.vector(x = lut[as.character(x = expanded$group)])
  expanded$coverage <- rollapply(data = expanded$norm.value, width = window, FUN = mean, align = 'center', fill = NA)
  return(expanded)
}

#' Extend
#'
#' Resize GenomicRanges upstream and or downstream.
#' From \url{https://support.bioconductor.org/p/78652/}
#'
#' @param x A range
#' @param upstream Length to extend upstream
#' @param downstream Length to extend downstream
#'
#' @importFrom GenomicRanges strand start end trim
#' @importFrom IRanges ranges IRanges
#' @export
Extend <- function(x, upstream = 0, downstream = 0) {
  if (any(strand(x = x) == "*")) {
    warning("'*' ranges were treated as '+'")
  }
  on_plus <- strand(x = x) == "+" | strand(x = x) == "*"
  new_start <- start(x = x) - ifelse(test = on_plus, yes = upstream, no = downstream)
  new_end <- end(x = x) + ifelse(test = on_plus, yes = downstream, no = upstream)
  ranges(x = x) <- IRanges(start = new_start, end = new_end)
  x <- trim(x = x)
  return(x)
}

#' GetReadsInRegion
#'
#' Extract reads for each cell within a given genomic region or set of regions
#'
#' @param object A Seurat object
#' @param region A genomic region, specified as a string in the format 'chr:start-end'. Can be a vector of regions.
#' @param assay Name of assay to use
#' @param fragment.path Path to indexed fragment file
#' @param group.by Cell grouping information to add
#' @param cells Cells to include. Default is all cells present in the object.
#' @param verbose Display messages
#'
#' @importFrom seqminer tabix.read.table
#'
#' @return Returns a data frame
#' @export
GetReadsInRegion <- function(
  object,
  region,
  assay = NULL,
  fragment.path = NULL,
  group.by = NULL,
  cells = NULL,
  verbose = TRUE
) {
  assay <- assay %||% DefaultAssay(object = object)
  if (is.null(group.by)) {
    group.by <- Idents(object = object)
  } else {
    meta.data <- object[[]]
    group.by <- meta.data[[group.by]]
    names(group.by) <- rownames(x = meta.data)
  }
  if (is.null(x = fragment.path)) {
    tools <- slot(object = object, name = 'tools')
    if ('fragments' %in% names(x = tools)) {
      if (assay %in% names(x = tools$fragments)) {
        fragment.path <- tools$fragments[[assay]]
      } else {
        stop('Fragment file not supplied for the requested assay')
      }
    } else {
      stop('Fragment file not set. Run SetFragments to set the fragment file path.')
    }
  } else if (!(all(file.exists(fragment.path, paste0(fragment.path, '.tbi'))))) {
    stop('Requested file does not exist or is not indexed')
  }
  if (verbose) {
    message('Extracting reads in requested region')
  }
  region <- CheckRegion(region = region)
  reads <- tabix.read.table(tabixFile = fragment.path, tabixRange = region)
  colnames(reads) <- c('chrom', 'start', 'stop', 'cell', 'reads')
  reads <- reads[reads$cell %in% names(group.by), ]
  if (!is.null(x = cells)) {
    reads <- reads[reads$cell %in% cells, ]
  }
  if (nrow(reads) == 0) {
    stop('No cells present in the requested region')
  }
  reads$length <- reads$stop - reads$start
  reads$group <- group.by[reads$cell]
  return(reads)
}

#' CheckRegion
#'
#' Make sure that the given region is ok. Raises error if not correct, otherwise returns region.
#'
#' @param region A genomic region, or a vector of regions
#' @export
CheckRegion <- function(
  region
) {
  if (grepl(pattern = '[0-9a-zA-Z_]*:[0-9]+-[0-9]+$', x = region)) {
    return(region)
  } else {
    stop('Bad region')
  }
}

#' Set the fragments file path for creating plots
#'
#' Give path of indexed fragments file that goes with data in the object.
#' Checks for a valid path and an index file with the same name (.tbi) at the same path.
#' Stores the path under the tools slot for access by visualization functions.
#' One fragments file can be stored for each assay.
#'
#' @param object A Seurat object
#' @param file Path to indexed fragment file. See \url{https://support.10xgenomics.com/single-cell-atac/software/pipelines/latest/output/fragments}
#' @param assay Assay used to generate the fragments. If NULL, use the active assay.
#'
#' @export
#'
SetFragments <- function(
  object,
  file,
  assay = NULL
) {
  assay <- assay %||% DefaultAssay(object = object)
  if (!(assay %in% names(x = slot(object = object, name = 'assays')))) {
    stop('Requested assay not present in object')
  }
  index.file <- paste0(file, '.tbi')
  if (all(file.exists(file, index.file))) {
    file <- normalizePath(path = file)
    current.tools <- slot(object = object, name = 'tools')
    current.tools$fragments[[assay]] <- file
    slot(object = object, name = 'tools') <- current.tools
    return(object)
  } else {
    stop('Requested file does not exist or is not indexed')
  }
}
