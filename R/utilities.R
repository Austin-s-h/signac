# Set a default value if an object is null
#
# @param lhs An object to set if it's null
# @param rhs The value to provide if x is null
#
# @return rhs if lhs is null, else lhs
#
# @author Hadley Wickham
# @references https://adv-r.hadley.nz/functions.html#missing-arguments
#
`%||%` <- function(lhs, rhs) {
  if (!is.null(x = lhs)) {
    return(lhs)
  } else {
    return(rhs)
  }
}

#' StringToGRanges
#'
#' Convert a genomic coordinate string to a GRanges object
#'
#' @param regions Vector of genomic region strings
#' @param sep Vector of separators to use for genomic string. First element is used to separate chromosome
#' and coordinates, second separator is used to separate start and end coordinates.
#' @return Returns a GRanges object
#' @importFrom GenomicRanges makeGRangesFromDataFrame
#' @importFrom tidyr separate
#' @examples
#' regions <- c('chr1-1-10', 'chr2-12-3121')
#' StringToGRanges(regions = regions)
#'
#' @export
StringToGRanges <- function(regions, sep = c("-", "-")) {
  ranges.df <- data.frame(ranges = regions)
  ranges.df <- separate(
    data = ranges.df,
    col = 'ranges',
    sep = paste0(sep[[1]], "|", sep[[2]]),
    into = c('chr', 'start', 'end')
  )
  granges <- makeGRangesFromDataFrame(df = ranges.df)
  return(granges)
}

#' GRangesToString
#'
#' Convert GRanges object to a vector of strings
#'
#' @param grange A GRanges object
#' @param sep Vector of separators to use for genomic string. First element is used to separate chromosome
#' and coordinates, second separator is used to separate start and end coordinates.
#' @importFrom GenomicRanges seqnames start end
#' @examples
#' GRangesToString(grange = blacklist_hg19)
#'
#' @export
GRangesToString <- function(grange, sep = c("-", "-")) {
  regions <- paste0(as.character(seqnames(x = grange)), sep[[1]], start(grange), sep[[2]], end(grange))
  return(regions)
}

#' CalculateCoverages
#'
#' Calculate normalized read coverage per base per cell group
#'
#' @param reads Dataframe containing reads for a region, generated by \code{GetReadsInRegion}
#' @param window Smoothing window to use
#'
#' @importFrom zoo rollapply
#' @importFrom data.table rbindlist
#' @export
CalculateCoverages <- function(
  reads,
  window = 100
) {
  cells.per.group <- table(reads$group)
  lut <- as.vector(x = cells.per.group)
  names(lut) <- names(x = cells.per.group)
  # TODO create list of vectors rather than binding dataframes, should be much faster
  expanded <- rbindlist(
    l = lapply(
      X = 1:nrow(reads),
      FUN = function(x) {
        interval <- as.numeric(reads[x, 'start']):as.numeric(reads[x, 'end'])
        df <- data.frame(
          position = interval,
          value = 1,
          cell = reads[x, 'cell'],
          group = reads[x, 'group']
        )
  }))
  expanded$norm.value <- expanded$value / as.vector(x = lut[as.character(x = expanded$group)])
  expanded$coverage <- rollapply(data = expanded$norm.value, width = window, FUN = mean, align = 'center', fill = NA)
  return(expanded)
}

#' ChunkGRanges
#'
#' Split a genomic ranges object into evenly sized chunks
#'
#' @param granges A GRanges object
#' @param nchunk Number of chunks to split into
#'
#' @return Returns a list of GRanges objects
#' @export
ChunkGRanges <- function(granges, nchunk) {
  chunksize <- as.integer(x = (length(granges) / nchunk))
  range.list <- sapply(1:nchunk, function(x) {
    chunkupper <- (x * chunksize) -1
    if (x == 1) {
      chunklower <- 1
    } else {
      chunklower <- (x-1) * chunksize
    }
    if (chunkupper > length(granges)) {
      chunkupper <- length(granges)
    }
    return(granges[chunklower:chunkupper])
  })
  return(range.list)
}

#' CreateMotifActivityMatrix
#'
#' Create a matrix of the normalized motif accessibility per cell
#'
#' @param object A Seurat object
#' @param assay Which assay to use. This must contain a Motif object.
#' @return Returns a matrix
#' @importFrom Matrix crossprod
#' @export
CreateMotifActivityMatrix <- function(
  object,
  assay = NULL
) {
  assay <- assay %||% DefaultAssay(object = object)
  motifs <- GetMotifData(object = object, assay = assay, slot = 'data')
  accessibility <- GetAssayData(object = object, assay = assay, slot = 'counts')
  motif.accessibility <- crossprod(x = motifs, y = accessibility)
  norm.motif.accessibility <- motif.accessibility / colSums(accessibility)
  return(norm.motif.accessibility)
}

#' Extend
#'
#' Resize GenomicRanges upstream and or downstream.
#' From \url{https://support.bioconductor.org/p/78652/}
#'
#' @param x A range
#' @param upstream Length to extend upstream
#' @param downstream Length to extend downstream
#'
#' @importFrom GenomicRanges strand start end trim
#' @importFrom IRanges ranges IRanges
#' @export
Extend <- function(x, upstream = 0, downstream = 0) {
  if (any(strand(x = x) == "*")) {
    warning("'*' ranges were treated as '+'")
  }
  on_plus <- strand(x = x) == "+" | strand(x = x) == "*"
  new_start <- start(x = x) - ifelse(test = on_plus, yes = upstream, no = downstream)
  new_end <- end(x = x) + ifelse(test = on_plus, yes = downstream, no = upstream)
  ranges(x = x) <- IRanges(start = new_start, end = new_end)
  x <- trim(x = x)
  return(x)
}

#' GetCellsInRegion
#'
#' Extract cell names containing reads mapped within a given genomic region
#'
#' @param tabix Tabix object
#' @param region A string giving the region to extract from the fragments file
#' @param cells Vector of cells to include in output. If NULL, include all cells
#'
#' @importFrom Rsamtools TabixFile scanTabix
#' @export
GetCellsInRegion <- function(tabix, region, cells = NULL) {
  if (!(class(region) == 'GRanges')) {
    region <- StringToGRanges(regions = region)
  }
  bin.reads <- scanTabix(file = tabix, param = region)
  reads <- sapply(X = bin.reads, FUN = ExtractCell)
  if (!is.null(x = cells)) {
    reads <- sapply(X = reads, FUN = function(x) {
      x <- x[x %in% cells]
      if (length(x = x) == 0) {
        return(NULL)
      } else {
        return(x)
      }
    })
  }
  nrep <- sapply(X = reads, FUN = length)
  regions <- rep(x = names(x = reads), nrep)
  cellnames <- as.vector(x = unlist(x = reads))
  return(list(cells = cellnames, region = regions))
}

#' GetReadsInRegion
#'
#' Extract reads for each cell within a given genomic region or set of regions
#'
#' @param object A Seurat object
#' @param region A genomic region, specified as a string in the format 'chr:start-end'. Can be a vector of regions.
#' @param assay Name of assay to use
#' @param fragment.path Path to indexed fragment file
#' @param group.by Cell grouping information to add
#' @param cells Cells to include. Default is all cells present in the object.
#' @param verbose Display messages
#' @param ... Additional arguments passed to \code{\link{StringToGRanges}}
#'
#' @importFrom Rsamtools TabixFile scanTabix
#'
#' @return Returns a data frame
#' @export
GetReadsInRegion <- function(
  object,
  region,
  assay = NULL,
  fragment.path = NULL,
  group.by = NULL,
  cells = NULL,
  verbose = TRUE,
  ...
) {
  assay <- assay %||% DefaultAssay(object = object)
  if (is.null(group.by)) {
    group.by <- Idents(object = object)
  } else {
    meta.data <- object[[]]
    group.by <- meta.data[[group.by]]
    names(group.by) <- rownames(x = meta.data)
  }
  if (is.null(x = fragment.path)) {
    tools <- slot(object = object, name = 'tools')
    if ('fragments' %in% names(x = tools)) {
      if (assay %in% names(x = tools$fragments)) {
        fragment.path <- tools$fragments[[assay]]
      } else {
        stop('Fragment file not supplied for the requested assay')
      }
    } else {
      stop('Fragment file not set. Run SetFragments to set the fragment file path.')
    }
  } else if (!(all(file.exists(fragment.path, paste0(fragment.path, '.tbi'))))) {
    stop('Requested file does not exist or is not indexed')
  }
  if (verbose) {
    message('Extracting reads in requested region')
  }
  if (!(class(x = region) == 'GRanges')) {
    region <- StringToGRanges(regions = region, ...)
  }
  tbx <- TabixFile(file = fragment.path)
  reads <- scanTabix(file = tbx, param = region)
  reads <- TabixOutputToDataFrame(reads = reads)
  reads <- reads[reads$cell %in% names(group.by), ]
  if (!is.null(x = cells)) {
    reads <- reads[reads$cell %in% cells, ]
  }
  if (nrow(reads) == 0) {
    stop('No cells present in the requested region')
  }
  reads$length <- reads$end - reads$start
  reads$group <- group.by[reads$cell]
  return(reads)
}

#' CountsInRegion
#'
#' Count reads per cell overlapping a given set of regions
#'
#' @param object A Seurat object
#' @param assay Name of assay in the object to use
#' @param regions A GRanges object
#' @param sep Separator to use when extracting genomic coordinates from the Seurat object
#' @param ... Additional arguments passed to \code{\link[IRanges]{findOverlaps}}
#'
#' @importFrom IRanges findOverlaps
#' @importFrom S4Vectors queryHits
#' @importFrom Matrix colSums
#'
#' @export
CountsInRegion <- function(
  object,
  assay,
  regions,
  sep = c("-", '-'),
  ...
) {
  obj.regions <- rownames(x = object[[assay]])
  obj.granges <- StringToGRanges(regions = obj.regions, sep = sep)
  overlaps <- findOverlaps(query = obj.granges, subject = regions, ...)
  hit.regions <- GRangesToString(grange = obj.granges[queryHits(x = overlaps)], sep = sep)
  data.matrix <- GetAssayData(object = object, assay = assay, slot = 'counts')[hit.regions, ]
  return(colSums(data.matrix))
}

#' ExtractCell
#'
#' Extract cell barcode from list of tab delimited character vectors (output of \code{\link{scanTabix}})
#'
#' @param x List of character vectors
#' @export
ExtractCell <- function(x) {
  if (length(x = x) == 0) {
    return(NULL)
  } else {
    tmp <- strsplit(x = x, split = "\t")
    return(unlist(x = tmp)[5*(1:length(x = tmp))-1])
  }
}

#' FractionCountsInRegion
#'
#' Find the fraction of counts per cell that overlap a given set of genomic ranges
#'
#' @param object A Seurat object
#' @param assay Name of assay to use
#' @param regions A GRanges object containing a set of genomic regions
#' @param sep The separator used to separate genomic coordinate information in the assay feature names
#' @param ... Additional arguments passed to \code{\link{CountsInRegion}}
#'
#' @export
FractionCountsInRegion <- function(
  object,
  assay,
  regions,
  sep = c("-", "-"),
  ...
) {
  reads.in.region <- CountsInRegion(
    object = object,
    regions = regions,
    assay = assay,
    sep = sep,
    ...
  )
  total.reads <- colSums(GetAssayData(object = object, assay = assay, slot = 'counts'))
  return(reads.in.region / total.reads)
}

#' TabixOutputToDataFrame
#'
#' Create a single dataframe from list of character vectors
#'
#' @param reads List of character vectors (the output of \code{\link{scanTabix}})
#' @param record.ident Add a column recording which region the reads overlapped with (default TRUE)
#' @importFrom data.table rbindlist
#' @return Returns a data.frame
#' @export
TabixOutputToDataFrame <- function(reads, record.ident = TRUE) {
  df.list <- lapply(X = 1:length(reads), FUN = function(x) {
    if (length(x = reads[[x]]) == 0) {
      return(NULL)
    }
    df <- read.table(file = textConnection(reads[[x]]), header = FALSE, sep = "\t", stringsAsFactors = FALSE)
    colnames(x = df) <- c('chr', 'start', 'end', 'cell', 'count')
    if (record.ident) {
      df$ident <- x
    }
    return(df)
  })
  return(rbindlist(df.list))
}
